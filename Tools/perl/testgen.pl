#!/usr/bin/perl -w

print STDERR "Usage: perl ../Tools/perl/testgen.pl [<cellname>] >sky130_stdcelllib_test/verilog/dv/stdcells/stdcells.c\n";

my @cells=map { s/\.cell$//; s/\.truthtable\.v$//; $_; } (defined($ARGV[0]) && -f $ARGV[0])?[$ARGV[0]]:<*.cell>;
my $useassert=0;

print <<EOF
// This file has been auto-generated by the testgen.pl
// It is a test-firmware for Caravel to automatically test all standard cells that are placed on the test-design, one by one, trying all possible input combinations and checking all outputs with assertions.
#include <defs.h>
#include <stub.c>
#include <assert.h>

char *current_cell="";
int current_test=0;
EOF
;

if($useassert)
{
  print <<EOF
void __assert_fail(const char *__assertion, const char *__file,unsigned int __line, const char *__function)
{
  print("Assertion failed! Cell: ");
  print(current_cell);
  // THIS FUNCTION SHOULD NOT RETURN, BUT I COULDNT FIGURE OUT HOW
}
EOF
  ;
}

print <<EOF

int get_la(int num)
{
  if(num<32) return ((reg_la0_data>>num)&1);
  if(num<64) return ((reg_la1_data>>(num-32))&1);
  if(num<96) return ((reg_la2_data>>(num-64))&1);
  return ((reg_la3_data>>(num-96))&1);
}
void write_la(int num, int value)
{
  if(num<32) reg_la0_data=reg_la0_data&(0xffffffff-(1<\<num)) | (value<<num);
  num-=32;
  if(num<32) reg_la1_data=reg_la1_data&(0xffffffff-(1<\<num)) | (value<<num);
  num-=32;
  if(num<32) reg_la2_data=reg_la2_data&(0xffffffff-(1<\<num)) | (value<<num);
  num-=32;
  if(num<32) reg_la3_data=reg_la3_data&(0xffffffff-(1<\<num)) | (value<<num);
}


int main()
{
EOF
;

my $reg=4; # Starting IO port


foreach my $cell (@cells)
{
  next unless(-f "$cell.truthtable.txt");
 
  open IN,"<$cell.truthtable.txt";

  my $header=<IN>; $header=~s/\s$//s;
  print "// Cell: $cell ($header)\n";
  print "  current_cell=\"$cell\";\n";

  #print STDERR $header;
  my @l=split "->",$header;
  my @ins=split " ",$l[0];
  my @outs=split " ",$l[1];
  my %map=();

  my @io=();
  print " print(\"Connecting Inputs of the cell $cell with the management core:\\n\");\n";
print <<EOF
  reg_spi_enable = 1;

        reg_mprj_io_31 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_30 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_29 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_28 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_27 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_26 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_25 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_24 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_23 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_22 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_21 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_20 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_19 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_18 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_17 = GPIO_MODE_MGMT_STD_OUTPUT;
        reg_mprj_io_16 = GPIO_MODE_MGMT_STD_OUTPUT;
EOF
;
  foreach(@ins)
  {
    $map{$_}=$reg;
    print "  reg_mprj_io_$reg = GPIO_MODE_MGMT_STD_OUTPUT; // $_\n";
    $io[$reg>>5]|=1<<($reg&31);
    $reg++;
  }
  print " print(\"Connecting the Outputs of the cell $cell with the management core:\\n\");\n";
  foreach(@outs)
  {
    $map{$_}=$reg;
    print "  reg_mprj_io_$reg = GPIO_MODE_USER_STD_OUTPUT; // $_\n";
    $reg++;
  }

  # Transferring the register values:
  print "  reg_mprj_xfer=1;\n";
  print "  while (reg_mprj_xfer == 1);\n";

print <<EOF
   // Flag start of the test
        reg_mprj_datal = 0xAB600000;
EOF
;

  $io[3]|=0xff000000;

  foreach(0 .. 3)
  {
    print "  reg_la".$_."_oenb = reg_la".$_."_iena=".sprintf("0x%08X",$io[$_]||0)."; // [".((($_+1)<<5)-1).":".($_<<5)."]\n"; # if(defined($io[$_]));
  }

  my $counter=0;
  print " print(\"Starting the tests:\\n\");\n";

  while(<IN>)
  {
    last if(m/^function:/);
    print "  current_test=$counter;\n";
    @l=split " ",$_;
    my $if=0;
    foreach(@l)
    {
      if(m/(\w+)=(\d)/)
      {
        print "  assert(get_la(".$map{$1}.")==$2); //$1\n" if($useassert);
	if(!$useassert)
	{
          print "  if(get_la(".$map{$1}.")!=$2) //$1\n";
	  print "  {\n";
	  print "    print(\"Assertion failed in cell $cell in test #$counter : $1 should be $2\\n\");\n";
          print "    reg_mprj_datal = 0xAB51EEEE; // Signal that the simulation has failed\n";
	  print "    return(-1);\n";
          print "  }\n";
	}
      }
      else
      {
        print "  write_la(".$map{$ins[$if]}.",$_); //$ins[$if]\n";
      }
      $if++;
    }
    print "  print(\"Test $counter for cell $cell successful\\n\");\n\n";
  
    $counter++;
  }
  print "print(\"Tests for $cell successful.\\n\");\n\n";
  close IN;
}

print "print(\"All standard cells have been tested successfully.\\n\");\n\n";
print "reg_mprj_datal = 0xAB51FEFE; // Signal that the simulation is done\n";


print "}\n";

print STDERR "Run the test by running: make verify-stdcells-rtl\n";
