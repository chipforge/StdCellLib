#!/usr/bin/perl -w
use strict;

if($#ARGV)
{
  print "spice2cell converts SPICE compatible .sp files to Popcorn compatible .cell files\n";
  print "Usage: spice2cell <filename.sp>\n";
}

# This is an example AND2X1 cell in SPICE format:
my $example=<<EOF
.subckt AND2X1 Y B vdd gnd A
M0 a_2_6# A vdd vdd pfet w=2u l=0.2u
+ ad=0p pd=0u as=0p ps=0u 
M1 vdd B a_2_6# vdd pfet w=2u l=0.2u
+ ad=0p pd=0u as=0p ps=0u 
M2 Y a_2_6# vdd vdd pfet w=2u l=0.2u
+ ad=0p pd=0u as=0p ps=0u 
M3 a_9_6# A a_2_6# Gnd nfet w=2u l=0.2u
+ ad=0p pd=0u as=0p ps=0u 
M4 gnd B a_9_6# Gnd nfet w=2u l=0.2u
+ ad=0p pd=0u as=0p ps=0u 
M5 Y a_2_6# gnd Gnd nfet w=1u l=0.2u
+ ad=0p pd=0u as=0p ps=0u 
.ends AND2X1
EOF
;

my %seenpins=();

our $name="UNNAMED";
our $pins="";

# Defines whether pins are inputs or outputs since SPICE does not have that concept
my %iomap=('A'=>'I','B'=>'I','C'=>'I','CN'=>'I','CLK'=>'I','D'=>'I','EN'=>'I','Q'=>'O','R'=>'I','S'=>'I','Y'=>'O','YC'=>'O','YS'=>'O','gnd'=>'','vdd'=>'','GND'=>'','VDD'=>'','Z'=>'O','DI'=>'I','DO'=>'O','OEN'=>'I','YPAD'=>'O','gnd2'=>'','vdd2'=>'','GND2'=>'','VDD2'=>'','vss'=>'','VSS'=>'');
my %mosmap=('pfet'=>'pmos','nfet'=>'nmos','nmos'=>'nmos','pmos'=>'pmos','hnfet'=>'nmos','hpfet'=>'pmos','enbsim3'=>'nmos','epbsim3'=>'pmos','sky130_fd_pr__nfet_01v8'=>'nmos','sky130_fd_pr__pfet_01v8'=>'pmos');
our %internalnets=();
our $internalcounter=0;
our $OUT;

# Generates and caches new names for the internal nets, which must be unique per cell
sub internal($)
{
  my $in=$_[0];
  return $in unless($in=~m/\#$/);
  #print $OUT "#$in? $internalcounter\n";
  $internalnets{$in}=$internalcounter++ if(!defined($internalnets{$in}));
  return $internalnets{$in};
}
sub internal2($)
{
  my $in=$_[0];
  return $in unless($in=~m/\@/);
  #print $OUT "#$in? $internalcounter\n";
  $internalnets{$in}=$internalcounter++ if(!defined($internalnets{$in}));
  return $internalnets{$in};
}

if($ARGV[0] && open IN,"<$ARGV[0]")
{
  while(<IN>)
  {
    if(m/^\.subckt (\w+) (.*)$/ || m/TOP LEVEL CELL: (\w+)\{sch\}()/ || m/^\*\*\.subckt (\w+) (.*)$/ )
    {
      $name=$1;
      $pins=$2;
      %internalnets=();
      $internalcounter=1;
      my %pins=();
      $pins{$iomap{$_}}{$_}++ foreach(split " ",$pins);
      $seenpins{$_}++ foreach(split " ",$pins);
      open $OUT,">".uc($name).".cell";
      print $OUT ".AUTOGENERATED by spice2cell script from $ARGV[0]\n";
      print $OUT ".inputs ".join(" ",reverse sort keys %{$pins{'I'}})."\n";
      print $OUT ".outputs ".join(" ",reverse sort keys %{$pins{'O'}})."\n";
      print $OUT ".ORDER \"MOSFET Gate Drain Source\"\n";
    }
    elsif(m/^X?[MNP]\d+ (\w+#?) (\w+#?) (\w+#?) (\w+#?) (pfet|nfet|nmos|pmos|hnfet|hpfet|enbsim3|epbsim3|sky130_fd_pr__nfet_01v8|sky130_fd_pr__pfet_01v8)/i)
    {
      my ($g,$d,$s,$m)=($2,$1,$3,$5);
      if($d=~m/^(vdd|gnd)$/i)
      {
        print "EXCHANGING SOURCE AND DRAIN: $_";
        ($s,$d)=($d,$s);
      }	
      $g=internal($g);
      $d=internal($d);
      $s=internal($s);
      print $OUT $mosmap{$m}." $g $d $s\n";
    }
    elsif(m/^X?[MXNP]\d+ (\w+#?) (\w+#?) (\w+#?) (pfet|nfet|nmos|pmos|hnfet|hpfet|enbsim3|epbsim3|sky130_fd_pr__nfet_01v8|sky130_fd_pr__pfet_01v8)/i)
    {
      my ($g,$d,$s,$m)=($2,$1,$3,$4);
      if($d=~m/^(vdd|gnd)$/i)
      {
        print "EXCHANGING SOURCE AND DRAIN: $_";
        ($s,$d)=($d,$s);
      }	
      $g=internal($g);
      $d=internal($d);
      $s=internal($s);
      print $OUT "".$mosmap{$m}." $g $d $s\n";
    }
    elsif(m/^M(n|p)mos\@\d+ (\w+\@?\d*) (\w+\@?\d*) (\w+\@?\d*) (\w+\@?\d*)/)
    {
      my ($g,$d,$s,$m)=($3,$2,$4,$1."mos");
      $g=internal2($g);
      $d=internal2($d);
      $s=internal2($s);
      print $OUT $mosmap{$m}." $g $d $s\n";
    }
    elsif(m/^R\w+\@\d+ (\w+\@?\d*) (\w+\@?\d*) (\d+\.?\d*)/)
    { # Rres@0 net@25 YPAD 100
      my ($n1,$n2,$v)=($1,$2,$3);
      $n1=internal2($n1);
      $n2=internal2($n2);
      print $OUT "res $n1 $n2 $v\n";
    }
    elsif(m/R\d+ (\w+#?) (\w+#?) (\d+)/)
    {
      my ($n1,$n2,$v)=($1,$2,$3);
      $n1=internal($n1);
      $n2=internal($n2);
      print $OUT "res $n1 $n2 $v\n";
    }
    elsif(m/^\*/)
    {
    }
    elsif(m/^\+/)
    {
    }
    elsif(m/^\s*$/)
    {
    }
    elsif(m/^\.global (\w+)/i)
    {
    }
    elsif(m/^\.ends?/)
    {
      $name="UNNAMED";
      $pins="";
      close $OUT;
    }
    else
    {
      print STDERR "Error: $_\n";
    }
  
  }
  close IN;
}

my $undefinedpins=0;
foreach(keys %seenpins)
{
  $undefinedpins++ unless(defined($iomap{$_}));
}

if($undefinedpins)
{
  print "Not yet defined pins, please update them in the sourcecode:\n(";
  foreach(sort keys %seenpins)
  {
    next if(defined($iomap{$_}));
    print "'$_'=>'I'," ;
  }
  print ")\n";
}
